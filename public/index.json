[
{
	"uri": "//localhost:62373/4_modulefour_backend/01_dropdownapis.html",
	"title": "Build Dropdown APIs",
	"tags": [],
	"description": "",
	"content": "Build Dropdown APIs In this section, we\u0026rsquo;ll create two APIs to populate the filter dropdowns with paper categories and locations.\nPaper Categories API Open the API Builder Tool (CMD/CTRL + U) Click \u0026ldquo;Add new API\u0026rdquo; Search for the integration to your database (AWS RDS if applicable) Copy and paste the below SQL inside the Superblocks editor: SELECT DISTINCT category_name FROM dm_operations.inventory; Click \u0026ldquo;Run API\u0026rdquo; Click the pencil icon next to \u0026lsquo;API1\u0026rsquo; and rename it to \u0026ldquo;get_papercategories\u0026rdquo; Location Data API Click \u0026ldquo;Add new API\u0026rdquo; Search for the integration to your database (same integration as the Paper Categories API) Copy and paste the below SQL inside the Superblocks editor: SELECT DISTINCT location_name FROM dm_operations.inventory; Click \u0026ldquo;Run API\u0026rdquo; Click the pencil icon next to \u0026lsquo;API1\u0026rsquo; and rename it to \u0026ldquo;get_locations\u0026rdquo; Connect APIs to Dropdown Components Hide the API Builder Tool (CMD/CTRL + U)\nSelect the first Dropdown component (Paper Categories)\nIn the Properties panel:\nFind the \u0026ldquo;Options\u0026rdquo; section Delete the placeholder data Add: {{get_papercategories.response}} Select the second Dropdown component (Locations)\nIn the Properties panel:\nFind the \u0026ldquo;Options\u0026rdquo; section Delete the placeholder data Add: {{get_locations.response}} Make sure to test both dropdowns after connecting the APIs. They should populate with actual categories and locations from your database. If data is not showing, ensure that you clicked \u0026ldquo;Run API\u0026rsquo; and double-check the output of your SQL queries.\nExample Here\u0026rsquo;s how you connect your dropdown components to the APIs: Next Steps Once the dropdowns are working, we\u0026rsquo;ll move on to creating the dynamic inventory data API.\n"
},
{
	"uri": "//localhost:62373/",
	"title": "Building a Full-Stack AI Application with AWS and Superblocks",
	"tags": [],
	"description": "",
	"content": "Building a Full-Stack AI Application with AWS and Superblocks [PLACEHOLDER - SUPERBLOCKS_LOGO] Welcome This hands-on workshop guides you through building a modern, enterprise-grade application that leverages the power of AWS services and Superblocks\u0026rsquo; low-code development platform. You\u0026rsquo;ll create a complete dashboard application with AI-powered insights, demonstrating how this powerful combination accelerates development and delivers business value.\nThroughout this workshop, you\u0026rsquo;ll learn how to:\nBuild a responsive frontend dashboard with modern UI components Create secure backend APIs that connect to AWS services Implement AI-powered insights using AWS Bedrock to analyze business data Set up proper governance and access controls Deploy your application to AWS infrastructure Key Benefits 10x Faster Development ‚ö°: Build in days what would normally take months Simplified AI Integration ü§ñ: Easily incorporate AWS Bedrock\u0026rsquo;s generative AI capabilities Enterprise-Ready üîí: Implement proper governance and security from day one Full-Stack Solution üèóÔ∏è: Create complete applications with frontend, backend, and AI components No ML Expertise Required üß†: Leverage advanced AI capabilities without specialized knowledge This workshop is ideal for developers, technical leaders, and solution architects looking to accelerate application development while incorporating powerful AI capabilities.\n::alert[The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services and Superblocks features can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.]{header=\u0026ldquo;Warning\u0026rdquo; type=\u0026ldquo;warning\u0026rdquo;}\nCost This workshop will incur costs associated with using Amazon RDS and AWS Bedrock. There are no costs associated with using Superblocks. It\u0026rsquo;s important to be aware that once the lab is completed, we highly advise following the instructions to delete any resources to avoid additional costs. Click here to navigate to the Clean-Up instructions. [REMINDER TO ADD CLEAN-UP SECTION]\nDuration The workshop is divided into several sections and typically takes 2-3 hours to complete.\nWhat You\u0026rsquo;ll Build In this workshop, you\u0026rsquo;ll build a complete inventory and sales management dashboard for a fictional retail company. The application will include:\nInteractive data visualizations for inventory and sales metrics AI-powered inventory analysis and forecasting Natural language query capabilities for business data Role-based access controls and governance Deployment to AWS infrastructure By the end of this workshop, you\u0026rsquo;ll have a functional application that demonstrates the power of combining AWS services with Superblocks\u0026rsquo; development platform.\n"
},
{
	"uri": "//localhost:62373/3_modulethree_frontend/01_headernavigation.html",
	"title": "Building the Header Navigation",
	"tags": [],
	"description": "",
	"content": "Building the Header Navigation In this section, we\u0026rsquo;ll create the header section of our dashboard with a navigation bar.\nSteps 1. Create the Header Section\nClick \u0026ldquo;Browse templates\u0026rdquo; in the top section Search for \u0026ldquo;Navigation bar with left aligned nav items\u0026rdquo; Click \u0026ldquo;Insert\u0026rdquo; 2. Add a Company Logo (optional)\nIf you want to add a custom logo, click the default \u0026ldquo;Acme inc.\u0026rdquo; icon at the top of the navigation bar and click delete Click \u0026ldquo;Add Component\u0026rdquo;, search for \u0026ldquo;Image\u0026rdquo;, and click the image component Click the image component and update the image URL in the properties panel Adjust the size of the image for proper display Example Here\u0026rsquo;s how your header should look after completion: Next Steps Once you\u0026rsquo;ve completed the header navigation, we\u0026rsquo;ll move on to creating the filter section.\n"
},
{
	"uri": "//localhost:62373/8_moduleeight_nextsteps/01_conclusion.html",
	"title": "Conclusion",
	"tags": [],
	"description": "",
	"content": "Workshop Next Steps Submodule Five Heading This paragraph block should be an brief explanation of the next steps to take after the prerequisites have been set up. Diagrams or code samples can be shown to give a visual explanation of what will be taking place during the building of the solution. An example of content guidance can be found at the bottom of this page.\n**REMOVE:** With the exception of _index.md, the module folders and filenames should be changed to better reflect their content, i.e. 1_Planning as the folder and 11_HowToBegin as the first submodule. Changing the \"weight\" value of the header is ultimately what reflects the order the modules are presented. Next Section Heading This paragraph block can optionally be utilized to lead into the next section of the workshop.\nExample of content guidance Configuring Your Solution While working through the workshop modules, you will progressively build a 3-tier web application by utilizing core AWS services. We will provide you with any code examples and any directions specific to the set up approach we will be utilizing. "
},
{
	"uri": "//localhost:62373/7_modulesix_deployment/01_deployingapp.html",
	"title": "Deploying Your Application",
	"tags": [],
	"description": "",
	"content": "Deploying Your Application In this section, you\u0026rsquo;ll learn how to deploy your Superblocks application and make changes available to all users. Superblocks provides multiple deployment methods that seamlessly integrate with your SDLC workflow.\nUnderstanding Deployment When deploying in Superblocks:\nYou\u0026rsquo;ll select a specific commit to deploy The chosen commit becomes the version served to end-users Code is served through Superblocks Global Edge Network for optimized performance When using Source Control, only commits on the default branch can be deployed. Make sure to merge your changes to make them deployable.\nDeployment Methods 1. Using Superblocks UI Navigate to Version Control:\nClick on the Version Control panel icon Scroll to the \u0026ldquo;Committed changes\u0026rdquo; section Deploy Your Changes:\nClick the menu icon for your commit Select \u0026ldquo;Deploy\u0026rdquo; Review and confirm the deployment 2. Continuous Deployment (GitHub Actions) Set Up GitHub Workflow: Navigate to your repo\u0026rsquo;s Actions tab Create a new workflow Use the following configuration: name: Deploy on: workflow_run: workflows: [\u0026#34;Sync changes to Superblocks\u0026#34;] types: - completed jobs: deploy: if: ${{ github.event.workflow_run.head_branch == \u0026#39;main\u0026#39; \u0026amp;\u0026amp; github.event.workflow_run.conclusion == \u0026#39;success\u0026#39; }} runs-on: ubuntu-latest name: Deploy steps: - name: Checkout uses: actions/checkout@v4 with: fetch-depth: 0 - name: Deploy uses: superblocksteam/deploy-action@v1 id: deploy with: token: ${{ secrets.SUPERBLOCKS_TOKEN }} 3. Using Superblocks CLI Install and Set Up: # Install the CLI globally npm i -g @superblocksteam/cli # Log in to the CLI superblocks login Export Your Tools: # Create and navigate to tools directory mkdir superblocks_tools cd superblocks_tools # Export your tools superblocks init [RESOURCE_URL] Deploy Changes: # Deploy the most recent commit superblocks deploy # Or deploy a specific commit superblocks deploy --commit-id \u0026lt;COMMIT_ID\u0026gt; Best Practices Always review changes before deployment Use continuous deployment for automated workflows Maintain proper version control hygiene The Superblocks Global Edge Network ensures optimal performance for users worldwide, regardless of their location.\nNext Steps In the next section, we\u0026rsquo;ll explore monitoring your deployed application and managing different environments.\n"
},
{
	"uri": "//localhost:62373/1_moduleone_overview.html",
	"title": "Overview",
	"tags": [],
	"description": "",
	"content": "Prerequisites and Setup What You\u0026rsquo;ll Learn In this first module, you\u0026rsquo;ll learn about:\nSuperblocks\u0026rsquo; Mission (10 minutes)\nUnderstanding the platform\u0026rsquo;s vision How Superblocks empowers developers Enterprise application development challenges Technical Challenges (15 minutes)\nCommon development complexities Traditional approach limitations Modern application requirements Solution Overview (15 minutes)\nHow Superblocks addresses challenges Platform architecture overview Key features and capabilities This module provides the foundation for understanding why Superblocks is essential for modern enterprise application development. The concepts covered here will be applied throughout the workshop.\nThe examples and sample code provided in this workshop are intended for learning purposes. While they demonstrate best practices, you should adapt them to meet your specific production requirements.\nNext Steps Let\u0026rsquo;s begin by exploring Superblocks\u0026rsquo; mission and how it\u0026rsquo;s transforming enterprise application development.\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/01_setupbedrock.html",
	"title": "Setting up AWS Bedrock",
	"tags": [],
	"description": "",
	"content": "Configuring AWS Bedrock in Superblocks üîå Superblocks makes it remarkably simple to integrate with AWS Bedrock. In this section, we\u0026rsquo;ll configure the connection between your Superblocks application and AWS Bedrock.\nStep 1: Configure AWS "
},
{
	"uri": "//localhost:62373/1_moduleone_overview/01_superblocksmission.html",
	"title": "Superblock&#39;s Mission",
	"tags": [],
	"description": "",
	"content": "Superblock\u0026rsquo;s Mission Empowering the next billion developers! Superblocks is the open enterprise application platform that empowers both developers and semi-technical teams to build, extend, and deploy applications seamlessly. By integrating with existing enterprise systems and providing centralized governance, authentication, permissions, and audit logs, Superblocks ensures security and compliance without sacrificing innovation.\nEnterprises today struggle with siloed development processes, limited collaboration, and slow innovation cycles due to fragmented tools and governance challenges. Traditional approaches create barriers between technical and business teams, resulting in development bottlenecks and underutilized talent. Superblocks solves these problems by creating a unified environment where diverse teams can collaborate effectively.\nBy leveraging AI and modern development practices, Superblocks enables organizations to deliver solutions faster while maintaining enterprise-grade security. Our platform democratizes software development, drives productivity across technical boundaries, and ultimately empowers the next billion developers to build the future of their organizations.\nPlatform Overview Next Steps In the next section, you will learn more about the challenges that Superblocks addresses and gain an understanding of the key technical concepts that are important for successfully leveraging the platform.\n"
},
{
	"uri": "//localhost:62373/6_moduleseven_governance/01_useridentification.html",
	"title": "User Identification",
	"tags": [],
	"description": "",
	"content": "User Identification In this section, we\u0026rsquo;ll implement user identification features in our dashboard.\nDisplay User Information Locate the User Icon\nFind the user icon in the top right of the page Select the icon component Configure User Display\nIn the Properties panel, find the \u0026ldquo;Label\u0026rdquo; field Enter the following JavaScript: {{Global.user.name}} Understanding User Context The Global.user object contains important user information:\nname: User\u0026rsquo;s full name email: User\u0026rsquo;s email address roles: User\u0026rsquo;s assigned roles permissions: User\u0026rsquo;s permissions Example of accessing user properties:\n// Get user\u0026#39;s name {{Global.user.name}} // Get user\u0026#39;s email {{Global.user.email}} // Check if user has specific role {{Global.user.roles.includes(\u0026#39;admin\u0026#39;)}} Best Practices Always validate user context before displaying sensitive information Use consistent user information display across your application Consider implementing a user profile section for detailed information The user context is automatically maintained by Superblocks and is always available through the Global.user object.\nTesting Verify that:\nUser name displays correctly in the UI User context updates when different users log in User information is consistent across the application Next Steps Now that we have user identification set up, we\u0026rsquo;ll implement role-based access control.\n"
},
{
	"uri": "//localhost:62373/2_moduletwo_preqandsetup/01_workshopoverview.html",
	"title": "Workshop Overview",
	"tags": [],
	"description": "",
	"content": "Workshop Overview This workshop guides you through building a full-stack dashboard application for [PLACEHOLDER] Company using Superblocks. You\u0026rsquo;ll create a modern, interactive dashboard that includes:\nDynamic data filtering Real-time statistics Interactive data visualization Role-based access control Technical Requirements Before starting, ensure you have:\n1. Web Browser\nChrome (recommended) Firefox Safari 2. Superblocks Account\nPermission to create apps (role can be owner, admin, or developer) 3. Database with proper credentials\nPermissions to write (set up mock data) Permissions to read 4. Basic understanding of SQL and Python\nKnowledge of JavaScript/TypeScript is not required Time Requirements The workshop is divided into five modules:\nPrerequisites and Setup (30 minutes) Building the Frontend (30 minutes) Building the Backend (30 minutes) Integrating with AWS Bedrock (20 minutes) Governance \u0026amp; Access Controls (30 minutes) Deploying the Application (10 minutes) Total estimated time is 2 to 3 hours\nNext Steps In the next section, we\u0026rsquo;ll cover the technical concepts you need to understand before starting the workshop.\n"
},
{
	"uri": "//localhost:62373/3_modulethree_frontend/02_filtersection.html",
	"title": "Creating the Filter Section",
	"tags": [],
	"description": "",
	"content": "Creating the Filter Section In this section, we\u0026rsquo;ll build the filter components that allow users to interact with the dashboard data.\nSteps 1. Add the Filter Section\nClick \u0026lsquo;+ Add Section\u0026rsquo; below the navigation bar (will automatically create a new section with a column component) Set the layout of the column component to \u0026ldquo;Horizontal\u0026rdquo; Set the \u0026ldquo;Vertical align\u0026rdquo; property of the column component to \u0026ldquo;Bottom\u0026rdquo; 2. Create the Filter Container\nClick the column component and within the column component click \u0026ldquo;Add Component\u0026rdquo; Search for \u0026ldquo;Dropdown\u0026rdquo; and add two dropdown components Search for \u0026ldquo;Button\u0026rdquo; and add two button components Configure the dropdown components: Update the Label property of the first dropdown to \u0026ldquo;Paper Categories\u0026rdquo; Update the Label property of the second dropdown to \u0026ldquo;Location\u0026rdquo; Set the width for both dropdowns to \u0026ldquo;Fill Parent\u0026rdquo; Configure the button components: Update the Label property of the first button to \u0026ldquo;Submit\u0026rdquo; Update the Label property of the second button to \u0026ldquo;Reset Filters\u0026rdquo; The horizontal layout ensures all filter components are aligned properly in a single row and removes the need to use CSS or Flexbox to align components.\nExample Here\u0026rsquo;s how you create your filter section: Next Steps After completing the filter section, we\u0026rsquo;ll move on to creating the hero stats section to display key performance indicators.\n"
},
{
	"uri": "//localhost:62373/4_modulefour_backend/02_inventoryapi.html",
	"title": "Creating the Inventory Data API",
	"tags": [],
	"description": "",
	"content": "Creating the Inventory Data API In this section, we\u0026rsquo;ll build a dynamic API that handles inventory data filtering based on their dropdown selections.\nInventory API Open the API Builder Tool (CMD/CTRL + U) Click \u0026ldquo;Add new API\u0026rdquo; Search for the integration to your database (AWS RDS if applicable) Add the below SQL and click \u0026ldquo;Run API\u0026rdquo; SELECT * FROM dm_operations.inventory WHERE ({{Dropdown1?.selectedOptionValue || \u0026#39;\u0026#39;}} = \u0026#39;\u0026#39; OR category_name = {{Dropdown1?.selectedOptionValue || \u0026#39;\u0026#39;}}) AND ({{Dropdown2?.selectedOptionValue || \u0026#39;\u0026#39;}} = \u0026#39;\u0026#39; OR location_name = {{Dropdown2?.selectedOptionValue || \u0026#39;\u0026#39;}}) Click the pencil icon next the API name and rename it to \u0026ldquo;get_inventory_data\u0026rdquo; The values Dropdown1 and Dropdown2 must equal the dropdown component names in the Properties panel in order for the python step to work. If you renamed those components, update the python step code to match the new names.\nConnect the Table Component Select the Table component In the Properties panel: Delete values in the \u0026ldquo;Data\u0026rdquo; field Add: {{get_inventory_data.response}} Set up the Button Actions Select the \u0026ldquo;Submit\u0026rdquo; button\nIn the Properties panel, at the bottom of the page:\nClick the + sign next to onClick underneath \u0026ldquo;Event handlers\u0026rdquo; Select \u0026ldquo;Run APIs\u0026rdquo; Within the \u0026ldquo;APIs (executed in parallel)\u0026rdquo; section, choose \u0026ldquo;get_inventory_data\u0026rdquo; Select the \u0026ldquo;Reset Filters\u0026rdquo; button\nIn the Properties panel, at the bottom of the page:\nClick the + sign next to onClick underneath \u0026ldquo;Event handlers\u0026rdquo; Select \u0026ldquo;Reset component to default\u0026rdquo; For the Component field, select \u0026ldquo;Dropdown1\u0026rdquo; from the dropdown (leave the Property field as \u0026ldquo;Selected Option\u0026rdquo;) Repeat this process again by clicking the + sign and adding another reset action for the \u0026ldquo;Dropdown2\u0026rdquo; component (ensuring the \u0026ldquo;Reset Filters\u0026rdquo; button is still in context) Click the + sign next to onClick underneath \u0026ldquo;Event handlers\u0026rdquo; for the third time\nSelect \u0026ldquo;Run APIs\u0026rdquo; Within the \u0026ldquo;APIs (executed in parallel)\u0026rdquo; section, choose \u0026ldquo;get_inventory_data\u0026rdquo; With the API now connected to the Table component, the table is now dynamically populated with data based on the selected dropdown options.\nTesting Select different combinations of filters Click Submit to verify filtering works Click Reset to verify all filters clear Verify table updates correctly If data is not populating in the table, try clicking the \u0026ldquo;Run API\u0026rdquo; button again in the API Builder Tool.\nNext Steps After implementing the inventory API and action buttons, we\u0026rsquo;ll move on to creating the hero stats APIs.\n"
},
{
	"uri": "//localhost:62373/6_moduleseven_governance/02_accesscontrol.html",
	"title": "Implementing Access Control",
	"tags": [],
	"description": "",
	"content": "Implementing Access Control In this section, we\u0026rsquo;ll implement role-based access control for different features of our dashboard.\nConfigure Access Rules Navigate to \u0026ldquo;Invoices\u0026rdquo; Tab\nFind the \u0026ldquo;Invoices\u0026rdquo; button in the navigation bar Access its properties in the Properties panel Set Visibility Rule\nLocate the \u0026ldquo;Visibility\u0026rdquo; property under \u0026ldquo;Layout\u0026rdquo; Add the following JavaScript: {{[\u0026#39;Oscar Martinez\u0026#39;, \u0026#39;Angela Schrute\u0026#39;, \u0026#39;Kevin Mallone\u0026#39;].includes(Global.user.name) ? true : false}} Understanding Access Control This implementation:\nRestricts \u0026ldquo;Invoices\u0026rdquo; access to specific users Hides the button completely for unauthorized users Maintains a clean UI for all users Additional Access Controls You can implement similar controls for:\nData Visibility // Show sensitive data only to managers {{Global.user.roles.includes(\u0026#39;manager\u0026#39;) ? sensitiveData : \u0026#39;***\u0026#39;}} Feature Access // Enable editing for admin users {{Global.user.roles.includes(\u0026#39;admin\u0026#39;)}} Action Permissions // Allow delete operations for specific roles {{[\u0026#39;admin\u0026#39;, \u0026#39;data_manager\u0026#39;].some(role =\u0026gt; Global.user.roles.includes(role))}} Best Practices Always implement access control at both UI and API levels Use consistent access patterns across your application Keep access rules simple and maintainable Document access requirements clearly UI-level access control is not sufficient on its own. Always implement corresponding backend access controls in your APIs.\nTesting Access Control Test with different user accounts:\nAccounting team members (Oscar, Angela, Kevin)\nShould see Invoices tab Can access financial data Other users\nShould not see Invoices tab Cannot access restricted features Next Steps In the final section, we\u0026rsquo;ll test our access control implementation.\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/02_inventoryanalysis.html",
	"title": "Inventory Analysis with Bedrock",
	"tags": [],
	"description": "",
	"content": "Building an Inventory Analysis Feature üì¶ Now that we have our Bedrock connection set up, let\u0026rsquo;s create a powerful inventory analysis feature that can provide insights about current inventory levels, identify potential stockouts, and recommend transfering strategies.\nStep 1: Create the Inventory Analysis API üîç Navigate to API Builder in the left sidebar Open the API Builder Tool (CMD/CTRL + U) Search for the integration to your database (AWS RDS if applicable) Name your API \u0026ldquo;generate_insights\u0026rdquo; Add the below SQL and rename the step to \u0026ldquo;get_input_data\u0026rdquo; SELECT ils.inventory_id, ils.sku, ils.product_name, ils.category_name, ils.location_name, ils.current_stock, ils.reorder_point, ils.stock_margin, ils.stock_status, sv.daily_velocity, po.total_quantity_ordered FROM dm_operations.inventory_location_status ils LEFT JOIN dm_operations.sales_velocity sv ON ils.inventory_id = sv.inventory_id AND ils.location_name = sv.location_name LEFT JOIN dm_operations.pending_orders po ON ils.inventory_id = po.inventory_id AND ils.location_name = po.location_name; Underneath the first step, add a new Python step Add the below Python code to limit the input data size and rename the step to \u0026ldquo;simplify_input_data\u0026rdquo; def prepare_data_for_llm(input_data): import json # Convert JSON object to a formatted string representation if isinstance(input_data, (dict, list)): # Convert to a nicely formatted string with indentation formatted_string = json.dumps(input_data, indent=2) # Truncate if too large max_chars = 8000 if len(formatted_string) \u0026gt; max_chars: formatted_string = formatted_string[:max_chars] + \u0026#34;\\n...(truncated)\u0026#34; return formatted_string # Call the function return prepare_data_for_llm(get_input_data.output) Add an additional Python step and the below code to call AWS Bedrock Rename the step to \u0026ldquo;send_to_bedrock\u0026rdquo; import boto3 import json def send_to_bedrock(text_data): # Truncate data text_data = text_data[:5000] # Create client client = boto3.client( service_name=\u0026#34;bedrock-runtime\u0026#34;, region_name=aws_region, aws_access_key_id=aws_access_key, aws_secret_access_key=aws_secret_key, ) # Create prompt as a message prompt = f\u0026#34;\u0026#34;\u0026#34;Analyze this inventory data: {text_data} Give me 3 inventory transfer recommendations across 3 different locations with: - Product name - From location - To location - Quantity - Priority score (0-100) - Cost savings - Reasoning - Analysis points (demand, cost, impact) Make sure to the reasoning is informative and not a generic statement. The reasoning should be different for each recommendation. Do not restate the analysis points in the response and can include information on forecased demand in rationale. Return as a JSON array.\u0026#34;\u0026#34;\u0026#34; # Make request with content as an array response = client.invoke_model( modelId=\u0026#34;amazon.nova-lite-v1:0\u0026#34;, body=json.dumps( {\u0026#34;messages\u0026#34;: [{\u0026#34;role\u0026#34;: \u0026#34;user\u0026#34;, \u0026#34;content\u0026#34;: [{\u0026#34;text\u0026#34;: prompt}]}]} ), contentType=\u0026#34;application/json\u0026#34;, accept=\u0026#34;application/json\u0026#34;, ) # Parse the response response_body = json.loads(response[\u0026#34;body\u0026#34;].read()) # Check response structure and extract accordingly if \u0026#34;content\u0026#34; in response_body and isinstance(response_body[\u0026#34;content\u0026#34;], list): output = response_body[\u0026#34;content\u0026#34;][0][\u0026#34;text\u0026#34;] else: # Fallback if response format is different output = str(response_body) return {\u0026#34;raw_output\u0026#34;: output} # Call the function return send_to_bedrock(simplify_input_data.output) Add a 4th and final Python step with the below code, and rename it to \u0026ldquo;format_output\u0026rdquo; import json import re def parse_text_recommendations(raw_output): try: # Get the raw output string if isinstance(raw_output, dict) and \u0026#34;raw_output\u0026#34; in raw_output: text = raw_output[\u0026#34;raw_output\u0026#34;] else: text = str(raw_output) # Extract the JSON array from the code block using regex json_match = re.search(r\u0026#34;```json\\s*\\n(.*?)\\n\\s*```\u0026#34;, text, re.DOTALL) if json_match: json_text = json_match.group(1) # Parse the extracted JSON directly recommendations = json.loads(json_text) return recommendations # If we can\u0026#39;t find a code block, try to parse the nested structure # First convert single quotes to double quotes for proper JSON parsing # But be careful with nested quotes in the JSON content if text.startswith(\u0026#34;{\u0026#39;\u0026#34;): # This is a Python dict representation, not valid JSON # Use ast.literal_eval which is safer than eval import ast data = ast.literal_eval(text) # Navigate through the nested structure if \u0026#34;output\u0026#34; in data and \u0026#34;message\u0026#34; in data[\u0026#34;output\u0026#34;]: message = data[\u0026#34;output\u0026#34;][\u0026#34;message\u0026#34;] if \u0026#34;content\u0026#34; in message and isinstance(message[\u0026#34;content\u0026#34;], list): content_text = message[\u0026#34;content\u0026#34;][0][\u0026#34;text\u0026#34;] # Extract JSON from code block json_match = re.search( r\u0026#34;```json\\s*\\n(.*?)\\n\\s*```\u0026#34;, content_text, re.DOTALL ) if json_match: json_text = json_match.group(1) recommendations = json.loads(json_text) return recommendations # If all else fails, run the original regex pattern pattern = r\u0026#34;(\\d+)\\.\\s+Product name:\\s+(.*?)\\nFrom location:\\s+(.*?)\\nTo location:\\s+(.*?)\\nQuantity:\\s+(.*?)\\nPriority score.*?:\\s+(.*?)\\nCost savings:\\s+(.*?)\\nReasoning:\\s+(.*?)(?=\\n\\n\\d+\\.|\\n\\nPlease|\\Z)\u0026#34; matches = re.findall(pattern, text, re.DOTALL) if matches: recommendations = [] for match in matches: recommendation = { \u0026#34;product_name\u0026#34;: match[1].strip(), \u0026#34;from_location\u0026#34;: match[2].strip(), \u0026#34;to_location\u0026#34;: match[3].strip(), \u0026#34;quantity\u0026#34;: match[4].strip(), \u0026#34;priority_score\u0026#34;: match[5].strip(), \u0026#34;cost_savings\u0026#34;: match[6].strip(), \u0026#34;reasoning\u0026#34;: match[7].strip(), } # Try to convert numeric fields try: recommendation[\u0026#34;quantity\u0026#34;] = int(recommendation[\u0026#34;quantity\u0026#34;]) except: pass try: recommendation[\u0026#34;priority_score\u0026#34;] = int( recommendation[\u0026#34;priority_score\u0026#34;] ) except: pass recommendations.append(recommendation) return recommendations return { \u0026#34;error\u0026#34;: \u0026#34;Could not parse recommendations from output\u0026#34;, \u0026#34;original_output\u0026#34;: text, } except Exception as e: # Custom extraction as a last resort try: # Direct extraction of the JSON array from the text start_idx = text.find(\u0026#34;[\\\\n {\u0026#34;) end_idx = text.find(\u0026#34;]\\\\n```\u0026#34;) if start_idx != -1 and end_idx != -1: json_text = text[start_idx : end_idx + 1] # Replace escaped characters json_text = ( json_text.replace(\u0026#34;\\\\n\u0026#34;, \u0026#34;\\n\u0026#34;) .replace(\u0026#39;\\\\\u0026#34;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;) .replace(\u0026#34;\\\\\u0026#39;\u0026#34;, \u0026#34;\u0026#39;\u0026#34;) ) recommendations = json.loads(json_text) return recommendations except: pass return {\u0026#34;error\u0026#34;: str(e), \u0026#34;original_output\u0026#34;: raw_output} # Call the function with the Bedrock output raw_output = send_to_bedrock.output return parse_text_recommendations(raw_output) Click Run API to test your API When crafting prompts for foundation models, be specific about the format and type of analysis you want. This helps ensure consistent, useful responses.\nYou\u0026rsquo;ve now created a powerful inventory analysis feature that leverages AWS Bedrock to provide actionable insights. This feature demonstrates how Superblocks and AWS Bedrock can work together to transform raw data into valuable business intelligence.\nNext Steps "
},
{
	"uri": "//localhost:62373/2_moduletwo_preqandsetup.html",
	"title": "Prerequisites and Setup",
	"tags": [],
	"description": "",
	"content": "Module 2: Prerequisites and Setup What You\u0026rsquo;ll Learn In this module, you\u0026rsquo;ll learn how to:\nSet up your development environment for building with Superblocks Configure necessary database connections and credentials Understand the key technical concepts behind the platform Prepare your local environment for development Time to Complete This module should take approximately [XX] minutes to complete.\nNext Steps Let\u0026rsquo;s begin with an overview of what we\u0026rsquo;ll be building in this workshop.\n"
},
{
	"uri": "//localhost:62373/1_moduleone_overview/02_technicalissueproblem.html",
	"title": "Technical Issue / Problem",
	"tags": [],
	"description": "",
	"content": "The Technical Challenge Building Modern Enterprise Applications In today\u0026rsquo;s fast-paced business environment, organizations face significant challenges when building and maintaining enterprise applications:\nKey Challenges Development Complexity Application Requirements Developer Challenges Multiple integrated systems Managing complex API integrations Complex data processing Implementing security patterns Real-time analytics Building data visualizations Responsive user interfaces Maintaining code quality Robust security controls Scaling development Technical Barriers Process Challenges Governance Issues Siloed teams Inconsistent governance Limited collaboration Security compliance Complex deployments Access management Manual workflows Audit requirements Integration bottlenecks Risk management How Does Superblocks Help? Superblocks addresses these challenges through a comprehensive solution that combines multiple powerful capabilities. At its core, Superblocks provides a unified development platform featuring an integrated UI Builder, API Management Console, Data Processing Tools, and Access Control System. This is complemented by enterprise-grade security features including role-based access control, audit logging, compliance monitoring, and secure data handling. To accelerate development, Superblocks offers rapid development tools such as component libraries, API templates, data connectors, and visualization builders. This integrated approach enables teams to build and deploy enterprise applications more efficiently while maintaining security and compliance standards.\nNext Steps Now that you understand the challenges, let\u0026rsquo;s set up your development environment and explore the technical concepts behind Superblocks.\n"
},
{
	"uri": "//localhost:62373/2_moduletwo_preqandsetup/02_setup.html",
	"title": "Workshop Resource Setup",
	"tags": [],
	"description": "",
	"content": "Workshop Resource Setup Prerequisites Before starting this workshop, you\u0026rsquo;ll need:\nA Superblocks Account Database Access Web Development Environment (Chrome recommended) Getting Started Superblocks Account Setup 1. Create a Superblock\u0026rsquo;s Account (if you don\u0026rsquo;t have one)\nVisit the Superblocks website superblocks.com Click \u0026ldquo;Try for free\u0026rdquo; at the top of the page Sign up with your work email (public email domains such as gmail, yahoo, outlook, etc. are blocked) Verify your email address 2. Login to Superblocks (already have an account)\nGo to the Superblocks website superblocks.com Click \u0026ldquo;Login\u0026rdquo; at the top of the page Login with your credentials Database Configuration If you\u0026rsquo;re attending a guided workshop, you\u0026rsquo;ll be provided with database credentials and can skip the RDS setup section below.\nOption 1: Guided Workshop 1. Locate Your Provided Credentials\nUse the workshop credentials provided by your instructor Note down the following: Database host Database name Username Password Option 2: Self-Paced Workshop (AWS RDS Setup) 1. Create an RDS Instance\nGo to the AWS Console and navigate to RDS Click \u0026ldquo;Create database\u0026rdquo; Choose PostgreSQL as the engine Select \u0026ldquo;Free tier\u0026rdquo; template if available Configure basic settings: DB instance identifier: sb-workshop-db Master username: postgres Create a secure master password 2. Configure Network Settings\nVPC: Choose your default VPC Public access: Yes (for workshop purposes only) VPC security group: Create new Allow inbound PostgreSQL (port 5432) from your IP 3. Configure Database Options\nInitial database name: workshop_db Leave other settings as default Click \u0026ldquo;Create database\u0026rdquo; 4. Wait for Database Creation (~5-10 minutes)\nNote down your database endpoint when available Save your credentials securely Configure Superblocks Connection In Superblocks, go to Integrations Click \u0026ldquo;Add Integration\u0026rdquo; Select \u0026ldquo;PostgreSQL\u0026rdquo; Enter your database details: Host: Your RDS endpoint or provided workshop host Port: 5432 (default for Postgres) Database: Your database name Username and password Click \u0026ldquo;Test Connection\u0026rdquo; to verify and click \u0026ldquo;Create\u0026rdquo; Setup Mock Data If you\u0026rsquo;re in a guided workshop, the mock data will already be populated in your provided database. You can skip this section.\nDatabase Structure The setup script will create three main tables:\ndm_operations.inventory\n- category_name (text) -- Paper category (e.g., \u0026#34;Copy Paper\u0026#34;, \u0026#34;Card Stock\u0026#34;) - location_name (text) -- Branch location - current_stock (integer) -- Current quantity in stock - reorder_point (integer) -- Minimum stock level before reorder - unit_price (decimal) -- Price per unit dm_operations.orders\n- order_id (integer) -- Unique order identifier - status (text) -- Order status (e.g., \u0026#34;Pending\u0026#34;, \u0026#34;Shipped\u0026#34;) - order_date (timestamp) -- When the order was placed - total_amount (decimal) -- Total order value dm_operations.sales\n- sale_id (integer) -- Unique sale identifier - sale_date (timestamp) -- When the sale occurred - location_name (text) -- Branch where sale occurred - total_amount (decimal) -- Total sale value Setup Steps 1. Clone the Workshop Repository\ngit clone https://github.com/superblocks-at/workshop-mock-data.git cd workshop-mock-data 2. Install Required Dependencies\npip install -r requirements.txt 3. Configure Database Connection\nCopy the example configuration file: cp config.example.py config.py Edit config.py with your database credentials: DB_CONFIG = { \u0026#39;host\u0026#39;: \u0026#39;your-db-endpoint\u0026#39;, \u0026#39;database\u0026#39;: \u0026#39;workshop_db\u0026#39;, \u0026#39;user\u0026#39;: \u0026#39;your-username\u0026#39;, \u0026#39;password\u0026#39;: \u0026#39;your-password\u0026#39; } 4. Run the Setup Script\npython setup_mock_data.py This will:\nCreate necessary tables Populate sample inventory data Add mock transaction history Generate test user accounts The setup script will overwrite existing data in the specified tables. Make sure you\u0026rsquo;re using a fresh database or one dedicated to this workshop.\nVerify Setup 1. Test Database Access\nSELECT COUNT(*) FROM dm_operations.inventory; 2. Verify Platform Access\nAccess to Application Builder Ability to create new APIs Permission to query the database If you can\u0026rsquo;t connect to the database or access any part of Superblocks, please ask for assistance or reach out to Superblocks support before proceeding.\nNext Steps After completing the setup, we\u0026rsquo;ll explore the technical concepts behind our application.\n"
},
{
	"uri": "//localhost:62373/3_modulethree_frontend.html",
	"title": "Building the Frontend",
	"tags": [],
	"description": "",
	"content": "Building the Frontend What You\u0026rsquo;ll Learn In this module, you\u0026rsquo;ll build the frontend of the [PLACEHOLDER] dashboard application. You\u0026rsquo;ll learn how to:\nCreate a responsive header with navigation Build filter components for data interaction Implement hero stats for key metrics Create a data table with detailed information Add interactive charts using Plotly Each section will guide you through the process of building these components using Superblocks\u0026rsquo; UI components and templates.\nTime to Complete This module should take approximately [XX] minutes to complete.\nNext Steps In the following sections, we\u0026rsquo;ll build each component of the frontend step by step, starting with the header navigation.\n"
},
{
	"uri": "//localhost:62373/3_modulethree_frontend/03_herostats.html",
	"title": "Building the Hero Stats Section",
	"tags": [],
	"description": "",
	"content": "Building the Hero Stats Section In this section, we\u0026rsquo;ll create the hero stats section that displays key metrics for the dashboard.\nSteps 1. Add the Hero Stats Section\nClick \u0026ldquo;+ Add Section\u0026rdquo; underneath the filter section (automatically adds a column component) Click the icon next to the \u0026ldquo;Add Component\u0026rdquo; button and select \u0026ldquo;Browse UI Templates\u0026rdquo; Search for \u0026ldquo;Hero stats with label below, percentage change beside\u0026rdquo; and click \u0026ldquo;Insert\u0026rdquo; 2. Configure the Hero Stats Section\nThe Hero Stats UI template comes with 3 stats by default and we want to add a fourth Select the third tile and copy it (CMD/CTRL + C) Press CMD/CTRL + V to paste it and create the fourth tile Update the section headers to: Total Inventory Low Stock Items Pending Orders YTD Sales Update the units of measurement for each stat (e.g. \u0026ldquo;$\u0026rdquo; for \u0026ldquo;Total Inventory\u0026rdquo; and \u0026ldquo;items\u0026rdquo; for \u0026ldquo;Low Stock Items\u0026rdquo;) Remove the +/- figures and parent container to simplify the display Example Here\u0026rsquo;s how your hero stats section should look after completion: Next Steps After completing the hero stats section, we\u0026rsquo;ll move on to creating the main body section with the data table and charts.\n"
},
{
	"uri": "//localhost:62373/4_modulefour_backend/03_herostatsapis.html",
	"title": "Implementing the Hero Stats APIs",
	"tags": [],
	"description": "",
	"content": "Implementing the Hero Stats APIs In this section, we\u0026rsquo;ll create APIs to power the hero stats section and use the Parallel block to run sets of API blocks at the same time. This is a powerful block that unlocks the ability to parallelize work in your APIs.\nHero Stats API Open the API Builder Tool (CMD/CTRL + U) Click \u0026ldquo;Add new API\u0026rdquo; Hover over \u0026ldquo;Control Blocks\u0026rdquo; and click \u0026ldquo;Run Parallel\u0026rdquo; Click the pencil icon next to \u0026lsquo;API1\u0026rsquo; and rename the API to \u0026ldquo;get_herostats\u0026rdquo; Configure Paths With a parallel control block, you can run multiple API blocks at the same time. This is a powerful feature that allows you to parallelize work in your APIs.\nClick on the Parallel block\nClick the plus icon under the Parallel block to add two new paths\nUpdate the \u0026ldquo;Path Names\u0026rdquo; to:\nPath1 = \u0026ldquo;get_inventory\u0026rdquo; Path2 = \u0026ldquo;get_lowstock\u0026rdquo; Path3 = \u0026ldquo;get_pendingorders\u0026rdquo; Path4 = \u0026ldquo;get_ytdsales\u0026rdquo; Within each Path, select the block and add the database integration. Add the below SQL to each block to pull data in parallel for the respective hero stats:\nTotal Inventory Value SELECT SUM(current_stock * unit_price) FROM dm_operations.inventory; Low Stock Items Count SELECT COUNT(*) FROM dm_operations.inventory WHERE current_stock \u0026lt;= reorder_point; Pending Orders Count SELECT COUNT(*) FROM dm_operations.orders WHERE status = \u0026#39;Pending\u0026#39;; Year-to-Date Sales SELECT SUM(total_amount) FROM dm_operations.sales WHERE EXTRACT(YEAR FROM sale_date) = EXTRACT(YEAR FROM CURRENT_DATE); Connect the Hero Stats Components Update each hero stat component with the corresponding API response. You can access the output of the Parallel block by referencing its path name (e.g., api_name.response.path_name).\nTotal Inventory: {{get_herostats.response.get_inventory}} Low Stock Items: {{get_herostats.response.get_lowstock}} Pending Orders: {{get_herostats.response.get_pendingorders}} YTD Sales: {{get_herostats.response.get_ytdsales}} Testing Verify all stats load correctly Confirm proper formatting of values If data is not populating in the table, try clicking the \u0026ldquo;Run API\u0026rdquo; button again in the API Builder Tool.\nNext Steps Now we\u0026rsquo;ll move on to creating the Plotly visualization APIs for our charts.\n"
},
{
	"uri": "//localhost:62373/2_moduletwo_preqandsetup/03_technicalconcepts.html",
	"title": "Technical Concepts",
	"tags": [],
	"description": "",
	"content": "Technical Concepts Superblocks Architecture Deployment Options Superblocks offers two deployment models to meet different organizational needs:\nCloud (Default)\nSimple to get started and manage Superblocks Cloud acts as a proxy to your integration No customer data storage in Superblocks On-premise Agent\nCustomer data remains within your VPC Ideal for strict compliance requirements Uses lightweight open-source agent On-Premise Agent Architecture The following diagram shows how the On-Premise Agent integrates with your infrastructure:\nCore Components Component Description Superblocks Cloud\n(Control Plane) ‚Ä¢ Manages user access and permissions across your organization\n‚Ä¢ Provisions and maintains agent security keys\n‚Ä¢ Provides centralized logging of all platform activities\n‚Ä¢ Handles user authentication and SSO integration On-Premise Agent\n(Compute Plane) ‚Ä¢ Runs your APIs and functions within your own infrastructure\n‚Ä¢ Manages connections to your databases and internal services\n‚Ä¢ Scales automatically based on workload demands\n‚Ä¢ Ensures reliable execution with automatic retries Data Plane\n(APIs \u0026amp; Databases) ‚Ä¢ Connects to your existing data sources (RDBMS, NoSQL, Data Warehouses)\n‚Ä¢ Supports bring-your-own-data model with no data storage in Superblocks\n‚Ä¢ Extensible with custom Python/JavaScript libraries for new integrations Request Flow The following diagram shows the request flow when using the On-Premise Agent:\nExecuting Requests via the On-Premise Agent The browser makes a separate secure request to the on-premise agent inside of your network to execute an API or database call The agent securely retrieves the API definition from the closest cache on the Global Superblocks Edge Network The agent executes the API inside your private network querying your databases or internal APIs and sends the data directly to the browser Next Steps Now that you understand the Superblocks architecture and security features, let\u0026rsquo;s proceed with building our application. As an optional step, you can set up the On-Premise Agent (OPA) locally for secure database access. This local setup can be valuable for development and testing purposes.\n"
},
{
	"uri": "//localhost:62373/6_moduleseven_governance/03_testing.html",
	"title": "Testing Access Controls",
	"tags": [],
	"description": "",
	"content": "Testing Access Controls In this final section, we\u0026rsquo;ll test our access control implementation to ensure it works as expected.\nPreview Mode Testing Access Preview Mode\nClick the \u0026ldquo;Preview\u0026rdquo; button in the top right This simulates how different users will see the application Test Different User Scenarios\nLog in as different users Verify feature visibility changes Confirm access restrictions work Test Cases Accounting Team Access Test as \u0026ldquo;Oscar Martinez\u0026rdquo;:\nVerify Invoices tab is visible Confirm access to financial data Check all accounting features work Test as \u0026ldquo;Regular User\u0026rdquo;:\nConfirm Invoices tab is hidden Verify restricted features are not accessible Ensure basic functionality works Common Issues and Solutions Visibility Issues\n// Problem: Inconsistent visibility {{Global.user.name === \u0026#39;Oscar Martinez\u0026#39;}} // Better approach {{[\u0026#39;Oscar Martinez\u0026#39;, \u0026#39;Angela Schrute\u0026#39;, \u0026#39;Kevin Mallone\u0026#39;].includes(Global.user.name)}} Role Checking\n// Problem: Single role check {{Global.user.roles.includes(\u0026#39;admin\u0026#39;)}} // Better approach: Multiple roles {{[\u0026#39;admin\u0026#39;, \u0026#39;manager\u0026#39;].some(role =\u0026gt; Global.user.roles.includes(role))}} Validation Checklist ‚úì User identification works correctly ‚úì Access controls are consistent ‚úì UI elements hide/show appropriately ‚úì Error messages are clear ‚úì No unauthorized access possible\nAlways test with multiple user accounts to ensure access controls work consistently across different scenarios.\nWorkshop Completion Congratulations! You have now:\nBuilt a complete dashboard frontend Implemented backend APIs Set up proper access controls Tested the entire application Your [PLACEHOLDER ]dashboard is now ready for production use!\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/03_uiforanalysis.html",
	"title": "UI Component for Analysis",
	"tags": [],
	"description": "",
	"content": "Create a UI Component for the Analysis üñ•Ô∏è Now that we have our Bedrock connection set up, let\u0026rsquo;s create a powerful inventory analysis feature that can provide insights about current inventory levels, identify potential stockouts, and recommend transfering strategies.\nStep 1: Create a UI Component for the Analysis üñ•Ô∏è Now, let\u0026rsquo;s create a UI component to display the inventory analysis:\nNavigate to UI Builder in the left sidebar Open your dashboard page Add a new container to your dashboard Add a heading component with the text \u0026ldquo;Inventory Analysis\u0026rdquo; Add a button component labeled \u0026ldquo;Analyze Inventory\u0026rdquo; Configure the button\u0026rsquo;s onClick event: Select \u0026ldquo;Run API\u0026rdquo; Choose your \u0026ldquo;InventoryAnalysis\u0026rdquo; API For the success action, select \u0026ldquo;Update State\u0026rdquo; Set the state key to \u0026ldquo;inventoryAnalysis\u0026rdquo; Add a text component below the button Configure the text component to display the analysis: Set the content to {{state.inventoryAnalysis.steps.AnalyzeInventory.body}} Enable markdown rendering Add a loading state to improve user experience ::alert[Superblocks\u0026rsquo; state management system makes it easy to store and display API results. The state is reactive, so your UI will automatically update when the data changes.]\nStep 3: Test Your Inventory Analysis Feature ‚úÖ Preview your application Click the \u0026ldquo;Analyze Inventory\u0026rdquo; button Wait for the analysis to complete Review the insights provided by AWS Bedrock Examine the visualization to identify at-risk products ::alert[You\u0026rsquo;ve now created a powerful inventory analysis feature that leverages AWS Bedrock to provide actionable insights. This feature demonstrates how Superblocks and AWS Bedrock can work together to transform raw data into valuable business intelligence.]{header=\u0026ldquo;Success\u0026rdquo; type=\u0026ldquo;success\u0026rdquo;}\n"
},
{
	"uri": "//localhost:62373/4_modulefour_backend.html",
	"title": "Building the Backend",
	"tags": [],
	"description": "",
	"content": "Building the Backend What You\u0026rsquo;ll Learn In this module, you\u0026rsquo;ll create the backend services that power the [PLACEHOLDER] dashboard. You\u0026rsquo;ll learn how to:\nBuild APIs to populate the Dropdown components Create an API to fetch inventory data with filtering Implement hero stats APIs for key metrics Set up Plotly visualizations Connect frontend components to backend services Each section will guide you through writing SQL queries, implementing Python data processing, and connecting the APIs to your frontend components.\nTime to Complete This module should take approximately [XX] minutes to complete.\nNext Steps Let\u0026rsquo;s begin by creating the APIs for our dropdown components. These APIs will form the foundation of our backend services, enabling dynamic data filtering and interactive visualizations in our dashboard.\n"
},
{
	"uri": "//localhost:62373/4_modulefour_backend/04_plotlyapis.html",
	"title": "Creating Plotly Visualization APIs",
	"tags": [],
	"description": "",
	"content": "Creating Plotly Visualization APIs In this section, we\u0026rsquo;ll create two APIs that generate Plotly charts for our dashboard: a location-based sales chart and a monthly trends chart.\nLocation Sales Chart API Open the API Builder Tool (CMD/CTRL + U) Click \u0026ldquo;Add new API\u0026rdquo; Search for the database integration Click the pencil icon next to \u0026lsquo;API1\u0026rsquo; and rename the API to \u0026ldquo;location_chart\u0026rdquo; Add the below SQL to the database integration:\nSELECT location_name, SUM(total_amount) as total_sales FROM dm_operations.sales GROUP BY location_name ORDER BY total_sales DESC; Add a Python Function Step and add the below code:\nimport plotly.express as px import pandas as pd fig = px.bar( Step1.output, x=\u0026#34;location_name\u0026#34;, y=\u0026#34;total_sales\u0026#34;, title=\u0026#34;Sales by Location\u0026#34;, labels={\u0026#34;total_sales\u0026#34;: \u0026#34;Total Sales ($)\u0026#34;, \u0026#34;location_name\u0026#34;: \u0026#34;Branch Location\u0026#34;}, color=\u0026#34;location_name\u0026#34;, ) fig.update_layout( template=\u0026#34;plotly_white\u0026#34;, showlegend=False, height=400 ) return fig.to_json() Monthly Trends Chart API Open the API Builder Tool (CMD/CTRL + U) Click \u0026ldquo;Add new API\u0026rdquo; Search for the Postgres integration Click the pencil icon next to \u0026lsquo;API1\u0026rsquo; and rename the API to \u0026ldquo;monthly_trends\u0026rdquo; Add the below SQL to the database integration:\nSELECT DATE_TRUNC(\u0026#39;month\u0026#39;, sale_date) as month, SUM(total_amount) as total_sales, COUNT(*) as number_of_orders FROM dm_operations.sales WHERE sale_date \u0026gt;= CURRENT_DATE - INTERVAL \u0026#39;12 months\u0026#39; GROUP BY DATE_TRUNC(\u0026#39;month\u0026#39;, sale_date) ORDER BY month; Add a Python Function Step: import plotly.graph_objects as go import pandas as pd monthly_data = pd.DataFrame(Step1.output) monthly_data[\u0026#34;total_sales\u0026#34;] = pd.to_numeric(monthly_data[\u0026#34;total_sales\u0026#34;]) monthly_data[\u0026#34;number_of_orders\u0026#34;] = pd.to_numeric(monthly_data[\u0026#34;number_of_orders\u0026#34;]) fig = go.Figure() # Add sales line fig.add_trace( go.Scatter( x=monthly_data[\u0026#34;month\u0026#34;], y=monthly_data[\u0026#34;total_sales\u0026#34;], name=\u0026#34;Total Sales\u0026#34;, line=dict(color=\u0026#34;blue\u0026#34;, width=2), ) ) # Add orders line fig.add_trace( go.Scatter( x=monthly_data[\u0026#34;month\u0026#34;], y=monthly_data[\u0026#34;number_of_orders\u0026#34;], name=\u0026#34;Number of Orders\u0026#34;, yaxis=\u0026#34;y2\u0026#34;, line=dict(color=\u0026#34;red\u0026#34;, width=2), ) ) # Update layout fig.update_layout( title=\u0026#34;Monthly Sales Trends (Last 12 Months)\u0026#34;, xaxis=dict(title=\u0026#34;Month\u0026#34;), yaxis=dict( title=\u0026#34;Total Sales ($)\u0026#34;, titlefont=dict(color=\u0026#34;blue\u0026#34;), tickfont=dict(color=\u0026#34;blue\u0026#34;), ), yaxis2=dict( title=\u0026#34;Number of Orders\u0026#34;, titlefont=dict(color=\u0026#34;red\u0026#34;), tickfont=dict(color=\u0026#34;red\u0026#34;), anchor=\u0026#34;x\u0026#34;, overlaying=\u0026#34;y\u0026#34;, side=\u0026#34;right\u0026#34;, ), template=\u0026#34;plotly_white\u0026#34;, height=400, ) return fig.to_json() Connect the Chart Components Configure Top Chart (Location Sales):\nSelect the first chart component Clear the \u0026ldquo;Header\u0026rdquo; value Set \u0026ldquo;Definition\u0026rdquo; to \u0026ldquo;Plotly\u0026rdquo; Set \u0026ldquo;Plotly chart JSON\u0026rdquo; to: {{location_chart.response}} Configure Bottom Chart (Monthly Trends):\nSelect the second chart component Clear the \u0026ldquo;Header\u0026rdquo; value Set \u0026ldquo;Definition\u0026rdquo; to \u0026ldquo;Plotly\u0026rdquo; Set \u0026ldquo;Plotly chart JSON\u0026rdquo; to: {{monthly_trends.response}} Plotly charts are interactive by default. Users can hover over data points, zoom, and pan the charts. If data is not populating in the table, try clicking the \u0026ldquo;Run API\u0026rdquo; button again in the API Builder Tool.\nTesting Verify both charts render correctly Test interactivity features Next Steps Now that we\u0026rsquo;ve completed all the backend APIs, we\u0026rsquo;ll move on to integrating with AWS Bedrock.\n"
},
{
	"uri": "//localhost:62373/3_modulethree_frontend/04_bodysection.html",
	"title": "Creating the Body Section",
	"tags": [],
	"description": "",
	"content": "Creating the Body Section In this section, we\u0026rsquo;ll build the main body of the dashboard, including the data table and charts.\nSteps 1. Create the Body Section\nAdd a new section for the body (automatically adds a column component) Set the section height to \u0026ldquo;Fill Viewport\u0026rdquo; Set the column layout to \u0026ldquo;Horizontal\u0026rdquo; 2. Add Container Components\nAdd 2 container components within the section Configure the left container: Width will automatically be set to \u0026ldquo;Fluid\u0026rdquo; Should occupy ¬æ of the section width Configure the right container: Set width to \u0026ldquo;Fill Parent\u0026rdquo; Update both containers to have \u0026ldquo;Vertical\u0026rdquo; layout Set both containers\u0026rsquo; height to \u0026ldquo;Fill Parent\u0026rdquo; 3. Add the Table Component\nAdd a Table component to the left container Set the table height to \u0026ldquo;Fill Parent\u0026rdquo; Remove some of the default selections for the table component: Remove the header (titled \u0026ldquo;Users\u0026rdquo; by default) Remove the search bar Remove the download button 4. Add Chart Components\nAdd 2 chart components to the right container Set both charts\u0026rsquo; height to \u0026ldquo;Fill Parent\u0026rdquo; The \u0026ldquo;Fill Parent\u0026rdquo; and \u0026ldquo;Fill Viewport\u0026rdquo; settings ensure your components use the available space effectively and create a responsive layout.\nExample Here\u0026rsquo;s how your body section should look after completion: Next Steps After completing the body section layout, we\u0026rsquo;ll move on to implementing the slide-out panel in the next module.\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/04_naturallanguagequeries.html",
	"title": "Natural Language Queries",
	"tags": [],
	"description": "",
	"content": "Building a Natural Language Query Interface üí¨ "
},
{
	"uri": "//localhost:62373/2_moduletwo_preqandsetup/04_opalocal.html",
	"title": "On-Premise Agent (Optional)",
	"tags": [],
	"description": "",
	"content": "On-Premise Agent Setup The Superblocks On-Premise Agent (OPA) allows you to securely connect to resources in your local environment. This section will guide you through setting up OPA locally.\nPrerequisites Before installing the OPA, ensure you have:\nDocker installed on your machine Access to a terminal/command prompt An agent token from Superblocks Installation Steps 1. Get Your Agent Token In Superblocks, go to Organization Settings ‚Üí Access Tokens Click Create token Name your token (e.g., \u0026ldquo;Local Agent Token\u0026rdquo;) Keep the expiration date as the default (90 days) For token type, select Agent key Copy the generated token - store it securely as it won\u0026rsquo;t be shown again 2. Deploy with Docker Run the following command, replacing {AGENT_KEY} with the token you just generated.\ncurl -s https://raw.githubusercontent.com/superblocksteam/agent/main/compose.yaml | \\ SUPERBLOCKS_AGENT_KEY=\u0026#34;{AGENT_KEY}\u0026#34; \\ SUPERBLOCKS_AGENT_HOST_URL=\u0026#34;http://localhost:8080\u0026#34; \\ SUPERBLOCKS_AGENT_TAGS=\u0026#34;profile:*\u0026#34; \\ SUPERBLOCKS_DOCKER_AGENT_TAG=\u0026#34;latest\u0026#34; \\ SUPERBLOCKS_AGENT_DATA_DOMAIN=\u0026#34;app.superblocks.com\u0026#34; \\ docker compose -p superblocks -f - up You should see Docker downloading images and starting containers. Keep this terminal window open to view logs.\nConfiguration with local services With the agent running, you can connect to locally hosted services as well:\nGo to the Integrations page and select which integrations to connect locally Click on \u0026hellip; followed by Manage Fill out the configuration form for your local server/database Important: For host addresses, use host.docker.internal instead of localhost to reach services from inside the Docker container Validating the Connection In Superblocks, go to Organization Settings ‚Üí On-Premise Agents Change the view from Cloud Deployment to On-Premise Deployment using the dropdown You should see your OPA with an Active status Getting Help If you encounter issues:\nCheck the Superblocks documentation Review agent logs for specific errors Check out the Troubleshooting OPA guide for common issues and solutions. The On-Premise Agent is optional for this workshop. If you\u0026rsquo;re using the cloud offering with a cloud database, you can skip this section.\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/05_conversationalassistant.html",
	"title": "Conversational Assistant",
	"tags": [],
	"description": "",
	"content": "Building a Conversational Business Assistant ü§ñ "
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock.html",
	"title": "Integrating with AWS Bedrock",
	"tags": [],
	"description": "",
	"content": "Enhancing Your Application with AWS Bedrock ü§ñ üöÄ What You\u0026rsquo;ll Learn In this module, you\u0026rsquo;ll integrate AWS Bedrock\u0026rsquo;s powerful generative AI capabilities into your Superblocks application to provide intelligent business insights. You\u0026rsquo;ll learn how to:\nConfigure AWS Bedrock integration within Superblocks with minimal code Build AI-powered inventory analysis features using foundation models AWS Bedrock is a fully managed service that offers a choice of high-performing foundation models (FMs) from leading AI companies through a unified API. With Superblocks, you can easily integrate these powerful AI capabilities into your applications without needing deep machine learning expertise.\n::alert[The examples and sample code provided in this workshop are intended to be consumed as instructional content. These will help you understand how various AWS services can be architected to build a solution while demonstrating best practices along the way. These examples are not intended for use in production environments.]{header=\u0026ldquo;Warning\u0026rdquo; type=\u0026ldquo;warning\u0026rdquo;}\nBusiness Value By integrating AWS Bedrock with your Superblocks application, you\u0026rsquo;ll enable:\nData-Driven Decision Making üìä: Surface actionable insights from your inventory and sales data Operational Efficiency ‚öôÔ∏è: Automate analysis that would typically require data science expertise Enhanced User Experience üåü: Provide natural language interfaces for complex data queries Predictive Capabilities üîÆ: Anticipate inventory needs before they become critical Rapid AI Implementation ‚ö°: Deploy AI features in days instead of months Time to Complete This module should take approximately 45 minutes to complete.\nNext Steps Let\u0026rsquo;s begin by setting up your AWS Bedrock connection in Superblocks.\n"
},
{
	"uri": "//localhost:62373/6_moduleseven_governance.html",
	"title": "Governance &amp; Access Controls",
	"tags": [],
	"description": "",
	"content": "Governance \u0026amp; Access Controls What You\u0026rsquo;ll Learn In this final module, you\u0026rsquo;ll implement governance and access controls for the [PLACEHOLDER] dashboard. You\u0026rsquo;ll learn how to:\nSet up user identification Display user information Handle user context Implement role-based access control Configure visibility rules Restrict access to sensitive features Test access control policies Verify user permissions Validate feature restrictions This module ensures your application properly handles user permissions and access controls, making it enterprise-ready.\nTime to Complete This module should take approximately [XX] minutes to complete.\nNext Steps PLACEHOLDER.\n"
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/06_predictiveanalytics.html",
	"title": "Predictive Analytics",
	"tags": [],
	"description": "",
	"content": "Implementing Predictive Analytics for Inventory üîÆ "
},
{
	"uri": "//localhost:62373/5_modulefive_bedrock/07_bedrocksummary.html",
	"title": "Bedrock Module Summary",
	"tags": [],
	"description": "",
	"content": "AWS Bedrock Integration Summary Congratulations! You\u0026rsquo;ve successfully integrated AWS Bedrock with your Superblocks application to create powerful AI-enhanced features:\nInventory Analysis üì¶: Automated insights about inventory status and reordering needs Natural Language Queries üí¨: A user-friendly interface for exploring sales data Predictive Analytics üîÆ: Forward-looking inventory forecasts to prevent stockouts Conversational Assistant ü§ñ: A business assistant that helps users interact with data Key Takeaways Simplified AI Integration: Superblocks makes it easy to connect to AWS Bedrock without deep ML expertise Business Value: These AI features provide actionable insights that drive better business decisions Development Efficiency: What would typically take weeks or months to build was accomplished in hours Customizability: The patterns you\u0026rsquo;ve learned can be applied to many different business scenarios ::alert[The combination of AWS Bedrock and Superblocks enables you to build sophisticated AI features with minimal code, making advanced AI capabilities accessible to developers of all skill levels.]{header=\u0026ldquo;Important\u0026rdquo; type=\u0026ldquo;info\u0026rdquo;}\nNext Steps Now that you\u0026rsquo;ve integrated AWS Bedrock, consider these next steps:\nCustomize the prompts to better fit your specific business needs Experiment with different foundation models to find the best fit for each use case Add more sophisticated data preprocessing to improve the quality of AI outputs Implement feedback loops to continuously improve your AI features ::alert[Remember that foundation models improve over time, and prompt engineering is an iterative process. Regularly review and refine your prompts to get the best results.]{header=\u0026ldquo;Tip\u0026rdquo; type=\u0026ldquo;info\u0026rdquo;}\nIn the next module, we\u0026rsquo;ll explore how to implement proper governance and access controls for your application.\n"
},
{
	"uri": "//localhost:62373/7_modulesix_deployment.html",
	"title": "Deployment",
	"tags": [],
	"description": "",
	"content": "Deploying Your Application What You\u0026rsquo;ll Learn In this final module, you\u0026rsquo;ll learn how to deploy your application. You\u0026rsquo;ll learn how to:\nSet up user identification Display user information Handle user context Implement role-based access control Configure visibility rules Restrict access to sensitive features Test access control policies Verify user permissions Validate feature restrictions This module ensures your application properly handles user permissions and access controls, making it enterprise-ready.\nTime to Complete This module should take approximately [XX] minutes to complete.\nNext Steps Let\u0026rsquo;s begin with an overview of what we\u0026rsquo;ll be building in this workshop.\n"
},
{
	"uri": "//localhost:62373/8_moduleeight_nextsteps.html",
	"title": "Next Steps",
	"tags": [],
	"description": "",
	"content": "Next Steps PLACEHOLDER \u0026hellip;\nPLACEHOLDER \u0026hellip;\n"
},
{
	"uri": "//localhost:62373/getting-started.html",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": "Workshop architecture The following architecture diagram illustrates the various components of the workshop.\nPreparing for the workshop Follow the installation instructions in this section to prepare your environment for the workshop.\nIf you are attending an AWS guided event, setup your environment here. If you are not participating in an AWS guided event, setup your environment here. ::alert[If you are running this workshop on your own AWS account, remember to delete all resources by following the Clean Up Resources section to avoid unnecessary charges.]{header=Note}\n"
},
{
	"uri": "//localhost:62373/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:62373/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]